use serde::{Deserialize, Serialize};
use nalgebra_glm as glm;
use crate::common::configs::ConfigTransform;

// Make sure to update this every time you need a new button listener!
pub const BUTTON_MAP: HashMap<String, fn()> = {

};

// Vertex
#[repr(C)]
#[derive(Copy, Clone, Debug, bytemuck::Pod, bytemuck::Zeroable)]
pub struct Vertex {
    pub position: [f32; 2],
    pub color: [f32; 4],
    pub texture: [f32; 2],
}

impl Vertex {
    const ATTRIBS: [wgpu::VertexAttribute; 3] =
        wgpu::vertex_attr_array![0 => Float32x2, 1 => Float32x4, 2 => Float32x2];

    pub fn desc<'a>() -> wgpu::VertexBufferLayout<'a> {
        use std::mem;

        wgpu::VertexBufferLayout {
            array_stride: mem::size_of::<Self>() as wgpu::BufferAddress,
            step_mode: wgpu::VertexStepMode::Vertex,
            attributes: &Self::ATTRIBS,
        }
    }
}

#[rustfmt::skip]
const rect_indices : Vec<u16> = vec![
    0, 2, 1,
    0, 3, 2,
];

const title_vert: Vec<Vertex> = vec![
    Vertex {
        position: [-1.0, -1.0],
        color: [1.0, 1.0, 1.0, 1.0],
        texture: [0.0, 1.0],
    }, // A
    Vertex {
        position: [-1.0, 1.0],
        color: [1.0, 1.0, 1.0, 1.0],
        texture: [0.0, 0.0],
    }, // B
    Vertex {
        position: [1.0, 1.0],
        color: [1.0, 1.0, 1.0, 1.0],
        texture: [1.0, 0.0],
    }, // C
    Vertex {
        position: [1.0, -1.0],
        color: [1.0, 1.0, 1.0, 1.0],
        texture: [1.0, 1.0],
    }, // D
];

// NOTE: all units are relative to either screen height or screen width
//    with the exception of aspect ratio, which is unitless

#[derive(Debug)]
pub struct DisplayGroup {
    pub id: String,
    pub screen: Option<Screen>,
    pub scene: Option<Scene>, // To load the scene graph
}

#[derive(Debug)]
pub struct Screen {
    pub id: String,
    pub background: Option<ScreenBackground>,
    pub items: Vec<ScreenObject>,
}

#[derive(Debug)]
struct ScreenBackground{
    pub aspect: f32,
    pub vbuf: wgpu::Buffer,
    pub ibuf: wgpu::Buffer,
    pub texture: String,
    pub tex_bind_group: wgpu::BindGroup,
}

#[derive(Debug)]
pub enum ScreenObject{
    Button{
        pub location: ScreenLocation,
        pub aspect: f32,    // both textures must be the same aspect ratio
        pub vertices: Vec<Vertex>,
        pub vbuf: wgpu::Buffer,
        pub ibuf: wgpu::Buffer,
        pub default_tint: glm::Vec4,
        pub hover_tint: glm::Vec4,
        pub default_texture: String,
        pub hover_texture: String,
        pub hover_uniform: wgpu::Buffer, // instance buffer, basically
        pub on_click: Option<String>,
    },
    Icon{
        pub location: ScreenLocation,
        pub aspect: f32,
        pub vertices: Vec<Vertex>,
        pub vbuf: wgpu::Buffer,
        pub ibuf: wgpu::Buffer,
        pub tint: glm::Vec4,
        pub texture: String,
        // pub instances: Vec<ConfigTransform>, // TODO: what did they do w/ the transform
        pub inst_range: Range,
    },
}

impl ScreenBackground{
    pub fn update(screen: &mut self, width: u32, height: u32, device: &wgpu::Device, queue: &wgpu::Queue) {
        let aspect: f32 = (width as f32) / (height as f32);
        const TITLE_AR: f32 = 16.0 / 9.0;
        let title_x_span_half = (glm::clamp_scalar(aspect / TITLE_AR, 0.0, 1.0)) / 2.0;
        let title_vert: Vec<Vertex> = vec![
            Vertex {
                position: [-1.0, -1.0],
                color: [1.0, 1.0, 1.0, 1.0],
                texture: [0.5 - title_x_span_half, 1.0],
            }, // A
            Vertex {
                position: [-1.0, 1.0],
                color: [1.0, 1.0, 1.0, 1.0],
                texture: [0.5 - title_x_span_half, 0.0],
            }, // B
            Vertex {
                position: [1.0, 1.0],
                color: [1.0, 1.0, 1.0, 1.0],
                texture: [0.5 + title_x_span_half, 0.0],
            }, // C
            Vertex {
                position: [1.0, -1.0],
                color: [1.0, 1.0, 1.0, 1.0],
                texture: [0.5 + title_x_span_half, 1.0],
            }, // D
        ];
        queue.write_buffer(
            screen.vbuf,
            0,
            bytemuck::cast_slice(&title_vert),
        );
    }
}